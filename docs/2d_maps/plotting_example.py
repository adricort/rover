#!/usr/bin/env python3

import cv2
import yaml
import numpy as np
from wand.image import Image

qr_x = [0,0,0]
qr_y = [0,0,0]

# Opening the images
# The screenshot
image = cv2.imread('/home/adricort/catkin_ws/src/rovy/2d_maps/map.png')
# The one generated by the four terminals roscore, map_proj, publish 1 1 0, etc.
image_pgm = cv2.imread('/home/adricort/catkin_ws/src/rovy/2d_maps/map.pgm')

#scaling up the image (not used so far)
image_scale_up = cv2.resize(image, (0, 0), fx=1, fy=1) # fx and fy are the factors

# Reading the pixels of both images to scale the drawings proportionaly
height, width, channel = image.shape
height_pgm, width_pgm, channel_pgm = image_pgm.shape

# To localize the origin and get the scaling parameters
# opening the map parameters generated calculated by the four-terminals process
map_yaml_file = open('/home/adricort/catkin_ws/src/rovy/2d_maps/map.yaml')
parsed_yaml_file = yaml.load(map_yaml_file, Loader=yaml.FullLoader)
# getting the origin as a float
map_origin = parsed_yaml_file["origin"]
# getting the inverse of the resolution as a float
map_inv_resolution = 1/parsed_yaml_file["resolution"]
# getting the scalling factor of both images to get the proportion of coordinates
scalling_factor = height/height_pgm # the screenshot with Shutter and the .pgm file 
# computing the origin in pixels
map_origin[0] = int(abs(float(map_origin[0])*(map_inv_resolution)*scalling_factor))
map_origin[1] = height-int(abs(float(map_origin[1])*(map_inv_resolution)*scalling_factor))

# To localize the qr coordinates
# opening the qr_tf parameters by the python node qr_tf_broadcaster_fromimage.py
qr_yaml_file = open('/home/adricort/catkin_ws/src/rovy/2d_maps/qr_tf.yaml')
# creating the dictionary
qr_yaml_dict = yaml.load(qr_yaml_file, Loader=yaml.FullLoader)

i = 0
# for every key (qr string) and value (coordinates), it will display dots on image
for keys, values in qr_yaml_dict.items():
    qr_x[i] = values[0]     # assigning the values x to new array for easy use
    qr_y[i] = values[1]     # assigning the values y to new array for easy use

    # computing the coordinates in pixels relative to the map_origin
    qr_x[i] = map_origin[0]+int(float(qr_x[i])*(map_inv_resolution)*scalling_factor)
    qr_y[i] = map_origin[1]-int(float(qr_y[i])*(map_inv_resolution)*scalling_factor)

    # drawing the circle of the respective qr
    cv2.circle(image_scale_up,(qr_x[i],qr_y[i]), 3, (255, 0, 0), 7)

    # parameters for the text
    font = cv2.FONT_HERSHEY_SIMPLEX
    coordinates = (qr_x[i]+10,qr_y[i]-10)     # a bit of offset for the text
    fontScale = 1
    color = (255, 0, 0)
    thickness = 2
    # writing text (PENDIENTE PONER EL NUMBRE DEL DICCIONARIO, HAY QUE CONCATENAR! (i))
    image_scale_up = cv2.putText(image_scale_up, str(i+1), coordinates, font, 
                       fontScale, color, thickness, cv2.LINE_AA)
    i = i + 1       # increment for the next key and value

print(qr_x," ",qr_y)

# drawing the circle of the origin
cv2.circle(image_scale_up,(map_origin[0],map_origin[1]), 3, (0, 0, 255), 7)

cv2.imshow('Upscaled Image', image_scale_up)

result = cv2.imwrite('/home/adricort/catkin_ws/src/rovy/2d_maps/final_map.png',image_scale_up)
if result==True:
    print("File saved successfully as .png")
else:
    print("Error in saving file .png")

with Image(filename ='final_map.png') as Sampleimg:  
    Sampleimg.format = 'tiff' 
    result = Sampleimg.save(filename ='final_map.tiff')
    print("File saved successfully as.tiff")

cv2.waitKey(0)
cv2.destroyAllWindows()